# メモリモデル比較

## 概要

| 言語 | 方式 | GC停止 | メモリ効率 | 安全性 |
|------|------|--------|-----------|--------|
| Rust | 所有権 | なし | 高 | コンパイル時保証 |
| Ruby | Mark & Sweep | あり | 中 | 実行時 |
| Go | 並行GC | 最小限 | 中 | 実行時 |
| C/C++ | 手動管理 | なし | 高 | 開発者依存 |
| Java | 世代別GC | あり | 中 | 実行時 |

## Rust: 所有権システム

### 3つのルール
1. 各値は1つの所有者を持つ
2. 所有者がスコープを抜けると値はドロップ
3. 所有権は移動（move）か借用（borrow）

### 借用ルール
- 不変参照 `&T` は複数OK
- 可変参照 `&mut T` は1つだけ
- 同時に不変と可変は不可

```rust
fn example() {
    let s = String::from("hello");  // s が所有
    let r1 = &s;                     // 不変借用
    let r2 = &s;                     // 不変借用 (OK)
    // let r3 = &mut s;              // エラー: 不変と可変の共存
    println!("{}, {}", r1, r2);
}  // s がドロップ
```

## Ruby: GC (Mark & Sweep)

```ruby
def create_objects
  arr = []
  1000.times { arr << Object.new }
  # メソッド終了後、arr への参照がなくなると GC 対象
end
```

### GC の動作
1. **Mark**: ルートから辿れるオブジェクトをマーク
2. **Sweep**: マークされていないオブジェクトを解放

### GC 停止 (Stop-the-World)
- GC 実行中はプログラムが一時停止
- レイテンシに影響

## 比較: メモリ安全性

| 問題 | Rust | Ruby | C |
|------|------|------|---|
| ダングリングポインタ | コンパイルエラー | GCが防ぐ | 発生しうる |
| 二重解放 | コンパイルエラー | GCが防ぐ | 発生しうる |
| メモリリーク | 可能(Rc循環) | 可能(循環参照) | 発生しうる |
| データ競合 | コンパイルエラー | GVLで軽減 | 発生しうる |

## 詳細

- [concepts/memory/](../../concepts/memory/)

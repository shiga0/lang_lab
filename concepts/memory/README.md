# メモリ管理比較

## 概要

| 言語 | 方式 | GC | 手動解放 | 特徴 |
|------|------|-----|---------|------|
| Rust | 所有権システム | なし | 不要 | コンパイル時に安全性保証 |
| Ruby | GC (Mark & Sweep) | あり | 不要 | 開発者はメモリを意識しない |
| C/C++ | 手動管理 | なし | 必要 | 完全な制御、危険も伴う |
| Go | GC (並行) | あり | 不要 | 低レイテンシGC |

## Rust: 所有権システム

### 3つのルール
1. 各値は**所有者**（変数）を持つ
2. 所有者は一度に**1つだけ**
3. 所有者がスコープを抜けると値は**ドロップ**

### 借用ルール
- 不変参照 (`&T`) は複数OK
- 可変参照 (`&mut T`) は1つだけ
- 不変と可変は同時に存在できない

```rust
// 所有権の移動
let s1 = String::from("hello");
let s2 = s1;           // s1 の所有権が s2 に移動
// println!("{}", s1); // エラー: s1 はもう使えない

// 借用
let s = String::from("hello");
let len = calculate_length(&s);  // 借用（所有権は移動しない）
println!("{} has length {}", s, len);  // s はまだ使える
```

## Ruby: ガベージコレクション

```ruby
# 開発者はメモリを意識しない
def create_objects
  arr = []
  1000.times { arr << Object.new }
  # メソッド終了後、arr が参照されなくなるとGCが回収
end

# 明示的なGC実行（通常は不要）
GC.start
```

## パフォーマンス特性

| 観点 | Rust | Ruby (GC) |
|------|------|-----------|
| レイテンシ | 予測可能 | GC停止時にスパイク |
| スループット | 高 | GCオーバーヘッド |
| メモリ効率 | 高（無駄なし） | 中（GC管理領域） |
| 開発効率 | 学習コスト高 | 意識不要で楽 |
